#!/usr/bin/env python3
import sys
from collections import deque

class NFA:
    def __init__(self):
        self.states: list
        self.alphabet: list
        self.start: str
        self.transitions: dict(dict(list)) = {}
        self.accepts: set

    def write_nfa(self, fileName):
        #open given file in write mode
        f = open(f'{fileName}', 'w')
        #write the simple variables using join on " "
        f.write(f'{" ".join(self.states)}\n')
        f.write(f'{" ".join(self.alphabet)}\n')
        f.write(f'{self.start}\n')
        f.write(f'{" ".join(list(self.accepts))}\n')
        #traverse the entire adjacency list to produce all of the transitions in the machine
        for states in self.transitions:
            for transitions in self.transitions[states]:
                for destinations in self.transitions[states][transitions]:
                    f.write(f'{states} {transitions} {destinations}\n')
        f.close()
                


    def read_nfa(self, fileName):
        fileNFA = open(f'{fileName}', 'r')
        lines = fileNFA.readlines()
        fileNFA.close()

        statesStr = lines[0]
        alphaStr = lines[1]
        startStr = lines[2]
        acceptStr = lines[3]

        # setting attributes
        self.states = statesStr.split()
        
        for i in range(len(self.states)):
            self.transitions[self.states[i]] = {}
        
        self.alphabet = alphaStr.split()
        

        self.start = startStr.strip()
        

        self.accepts = set(acceptStr.split())
        

        # rest on lines is transitions, loop until done

        # use len of self.states and populate dictionary of transitions with an empty dictionary for each state

        for i in range(4, len(lines)):
            elements = lines[i].split()
            if elements[1] in self.transitions[elements[0]]:
                self.transitions[elements[0]][elements[1]].append(elements[2])
            else:
                self.transitions[elements[0]][elements[1]] = [elements[2]]

        #print(self.transitions)

        return self

    def match(self, string):
        
        #queue that will hold node information
        frontier = deque([(0, (-1, 'q', '&', self.start))])
        #dict that will track all taken paths
        paths: dict((int, str, str, str)) = {}
        #set that will keep track of each node already processed
        visited = set()
        #variable that will hold node for each processing iteration, declared outside of loop to prevent repeated declaration and loss of scope
        node = ()
        #accept condition declared outside of loop to prevent loss of scope
        accept = False
        length = len(string)

        while (frontier):

            #pop the front of the queue to process a node in the NFA
            node = frontier.popleft()
            
            #set variables to avoid repeated index and increase clarity
            old_path = node[-1]
            new_path = ()
            curr_depth = node[0]
            curr_state = node[-1][-1]
            
            #check if node has been previously processed, if it has do not process it again, if it hasn't mark it as processed
            if (curr_depth, curr_state) in visited:
                continue
            else:
                visited.add((curr_depth, curr_state))
            
            #check to see if current node is an accept state and is at the end of the string, if so break with exit status True
            if curr_state in self.accepts and curr_depth >= length:
                accept = True
                break

            #check for epsilon transitions from the current state and add any nodes to the frontier
            if '&' in self.transitions[curr_state]:
                for state in self.transitions[curr_state]['&']:
                    if (curr_depth, state) in visited:
                        continue
                    new_path = (curr_depth, curr_state, '&', state)
                    paths[new_path] = old_path
                    frontier.append((curr_depth, (new_path)))
            
            #check if the end of the string has been reached, if so stop processing current node
            if curr_depth >= length:
                continue

            curr_char = string[curr_depth]
                
            #check for any transitions from the current state on the current symbol in the string and any nodes to the frontier
            if curr_char not in self.transitions[curr_state]:
                continue
            else:
                for state in self.transitions[curr_state][curr_char]:
                    if (curr_depth + 1, state) in visited:
                        continue
                    new_path = (curr_depth + 1, curr_state, curr_char, state)
                    paths[new_path] = old_path
                    frontier.append((curr_depth + 1, (new_path)))
        return (accept, paths, node[-1])


def main():
    testNFA = NFA()
    testNFA.read_nfa(sys.argv[1])
    accepts, paths, back_trace = testNFA.match(sys.argv[2])
    final = deque([])

    if accepts:
        print('accept')
        #for step in range(1,len(path)):
        #    line = f'{path[step][0]} {path[step][1]} {path[step][2]}'
        #    print(line)

        while (back_trace[0] != -1):
            final.append((back_trace[1], back_trace[2], back_trace[3]))
            back_trace = paths[back_trace]
        while (final):
            print(f'{" ".join(final.pop())}')

    else:
        print('reject')

if __name__ == '__main__':
    main()

