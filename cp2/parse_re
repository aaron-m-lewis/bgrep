#!/usr/bin/env python3

import sys

def main(regex=sys.argv[1] + '⊣'):
   
    stack: list[(str, str)]  = [('$', '')]
    read_dict: dict[str, set] = {'a': {'$', '(', '|', 'T'}, '(': {'$', '(', '|', 'T'}, ')': {'E'}, '|': {'E'}, '*': {'P'}}

    while (True):
        if regex[0] == '⊣' and stack[-1][0] == 'E':
            print(stack[-1][1])
            break
        if regex[0] in {'(', ')', '|', '\\', '*'}:
            if stack[-1][0] in read_dict[regex[0]]:
                stack.append((regex[0], ''))
                regex = regex[1:]
                continue
        elif stack[-1][0] in read_dict['a'] and regex[0] != '⊣':
            stack.append((regex[0], ''))
            regex = regex[1:]
            continue
  
        try:
            match (stack[-1][0]):
                case 'M': 
                    if stack[-2][0] == '|' and stack[-3][0] == 'E': #rule to pop E | M
                        tree = ['', '', '']
                        for i in range(0, 3):
                            tree[i] = stack.pop()[1]
                        stack.append(('E', f'union({tree[2]},{tree[0]})'))
                    elif stack[-2][0] in {'$', '('}: #rule to pop M
                        stack.append(('E', f'{stack.pop()[1]}'))
                case 'T':
                    if len(regex) == 1 or regex[0] in {'|', ')', '⊣'}: #rule to pop T
                        stack.append(('M', f'{stack.pop()[1]}'))  
                case 'F':
                    if stack[-2][0] == 'T': #rule to pop TF
                        tree = ['', '']
                        for i in range(0, 2):
                            tree[i] = stack.pop()[1]
                        stack.append(('T', f'concat({tree[1]},{tree[0]})'))
                    elif stack[-2][0] in {'$', '(', '|'}: #rule to pop F
                        stack.append(('T', f'{stack.pop()[1]}'))  
                case '*':
                    if stack[-2][0] == 'P': #rule to pop P
                        tree = ['', '']
                        for i in range(0, 2):
                            tree[i] = stack.pop()[1]
                        stack.append(('F', f'star({tree[1]})'))
                case 'P':
                    if len(regex) == 1 or regex[0] != '*': #rule to pop P*
                        stack.append(('F', f'{stack.pop()[1]}'))  
                case ')': #rule to pop ( E )
                    if stack[-2][0] == 'E' and stack[-3][0] == '(': #rule to pop ( E )
                        tree = ['', '', '']
                        for i in range(0, 3):
                            tree[i] = stack.pop()[1]
                        stack.append(('P', f'{tree[1]}'))  
                case _:
                    if stack[-1][0] not in {'(', ')', '|', '\\', '*', '$'} and stack[-1][0].isascii():
                        stack.append(('P', f'symbol("{stack.pop()[0]}")'))  
                    elif stack[-1][0] in {'$', '(', '|'} and regex[0] in {'|', ')', '⊣'}: #rule to pop nothing
                        stack.append(('M', 'epsilon()'))  
        except:
            if stack[-1][0] in {'$', '(', '|'} and regex[1] in {'|', ')', '⊣'}: #rule to pop nothing
                stack.append(('M', 'epsilon()'))  
            else:
                break
        

if __name__ == '__main__':
    main()
